// Start: Code generated by ChatGPT

const express = require("express");

// Prefer native bcrypt; fall back to bcryptjs if native build isn't available
let bcrypt;
try {
  bcrypt = require("bcrypt");
} catch {
  bcrypt = require("bcryptjs");
}

const { db } = require("../database.js");
const router = express.Router();

router.get("/login", (req, res) => {
  if (req.session?.loggedIn) return res.redirect("/");
  const next = req.query.next && req.query.next.startsWith("/") ? req.query.next : "";
  res.render("auth/login", { title: "Login", next });
});

router.post("/login", (req, res) => {
  const username = (req.body?.username || "").trim();
  const password = req.body?.password || "";
  const next = req.body?.next && req.body.next.startsWith("/") ? req.body.next : "/";

  if (!username || !password) {
    return res.status(400).render("auth/login", {
      title: "Login",
      error: "Please enter both username and password.",
    });
  }

  // ⬇️ include is_admin so we can store it in the session
  const sql = `SELECT id, username, passwordHash, is_admin FROM users WHERE username = ?`;
  db.get(sql, [username], async (err, user) => {
    if (err) {
      console.error("DB error:", err.message);
      return res.status(500).render("auth/login", {
        title: "Login",
        error: "Internal error. Please try again.",
      });
    }

    if (!user) {
      return res.status(401).render("auth/login", {
        title: "Login",
        error: "Invalid username or password.",
      });
    }

    try {
      const ok = await bcrypt.compare(password, user.passwordHash);
      if (!ok) {
        return res.status(401).render("auth/login", {
          title: "Login",
          error: "Invalid username or password.",
        });
      }

      // ✅ Success: set session flags (including is_admin)
      req.session.loggedIn = true;
      req.session.userId = user.id;
      req.session.username = user.username;
      req.session.is_admin = !!user.is_admin; // <-- ADD THIS

      // Ensure session is saved before redirect
      req.session.save(() => res.redirect(next));
    } catch (e) {
      console.error("bcrypt error:", e);
      return res.status(500).render("auth/login", {
        title: "Login",
        error: "Internal error. Please try again.",
      });
    }
  });
});

router.get("/logout", (req, res) => {
  req.session.destroy((err) => {
    if (err) console.error("Session destroy error:", err);
    res.redirect("/");
  });
});

// GET /register
router.get("/register", (req, res) => {
  if (req.session?.loggedIn) return res.redirect("/");
  res.render("auth/register", { title: "Register" });
});

// POST /register — auto-login on success
router.post("/register", async (req, res) => {
  const { username, password, confirmPassword } = req.body || {};

  // Basic server-side validation
  if (!username || !password || !confirmPassword) {
    return res.status(400).render("auth/register", {
      title: "Register",
      error: "Please fill all fields.",
      username,
    });
  }
  if (username.length < 3) {
    return res.status(400).render("auth/register", {
      title: "Register",
      error: "Username must be at least 3 characters.",
      username,
    });
  }
  if (password.length < 6) {
    return res.status(400).render("auth/register", {
      title: "Register",
      error: "Password must be at least 6 characters.",
      username,
    });
  }
  if (password !== confirmPassword) {
    return res.status(400).render("auth/register", {
      title: "Register",
      error: "Passwords do not match.",
      username,
    });
  }

  // Prefer native bcrypt; fall back to bcryptjs
  let bcrypt;
  try {
    bcrypt = require("bcrypt");
  } catch {
    bcrypt = require("bcryptjs");
  }

  // Check for existing user
  const sqlFind = `SELECT id FROM users WHERE username = ?`;
  db.get(sqlFind, [username], async (err, existing) => {
    if (err) {
      console.error("DB error:", err.message);
      return res.status(500).render("auth/register", {
        title: "Register",
        error: "Internal error. Please try again.",
        username,
      });
    }
    if (existing) {
      return res.status(409).render("auth/register", {
        title: "Register",
        error: "Username is already taken.",
        username,
      });
    }

    try {
      const passwordHash = await bcrypt.hash(password, 10);
      const sqlInsert = `INSERT INTO users (username, passwordHash, createdAt) VALUES (?, ?, datetime('now'))`;

      db.run(sqlInsert, [username, passwordHash], function (insertErr) {
        if (insertErr) {
          console.error("DB insert error:", insertErr.message);
          return res.status(500).render("auth/register", {
            title: "Register",
            error: "Could not create account. Please try again.",
            username,
          });
        }

        // Auto-login: create a session and redirect home
        const newUserId = this.lastID;

        // If you want a clean session, regenerate first (recommended)
        req.session.regenerate((regenErr) => {
          if (regenErr) {
            console.error("Session regenerate error:", regenErr);
            // Fallback: set on current session
          }

          req.session.loggedIn = true;
          req.session.user = { id: newUserId, username };

          // Ensure session is saved before redirecting
          req.session.save((saveErr) => {
            if (saveErr) {
              console.error("Session save error:", saveErr);
              // As a fallback, still redirect
            }
            return res.redirect("/");
          });
        });
      });
    } catch (hashErr) {
      console.error("Hash error:", hashErr);
      res.status(500).render("auth/register", {
        title: "Register",
        error: "Internal error. Please try again.",
        username,
      });
    }
  });
});

module.exports = router;

// End: Code generated by ChatGPT
